'use strict'

const AWS = require('aws-sdk')
const uuid = require('uuid')
const winston = require('winston')

const config = {
  eventLogger: {
    type: process.env.EVENT_LOGGER_TYPE || undefined,
    path: process.env.EVENT_LOGGER_PATH || '/var/log/jumpcloud-events/webui-events.log',
    aws: {
      accessKeyId: process.env.EVENT_LOGGER_AWS_ACCESS_KEY_ID,
      region: process.env.EVENT_LOGGER_AWS_REGION,
      secretAccessKey: process.env.EVENT_LOGGER_AWS_SECRET_ACCESS_KEY,
    },
    queue: {
      url: process.env.EVENT_LOGGER_QUEUE_URL,
    },
    streamName: process.env.EVENT_LOGGER_STREAM_NAME,
  },
}

class SQSEventLogger {
  constructor(options, queue, streamName, logger) {
    this._sqs = new AWS.SQS({
      accessKeyId: options.accessKeyId,
      region: options.region,
      secretAccessKey: options.secretAccessKey,
    })
    this._kinesis = new AWS.Kinesis({
      apiVersion: '2013-12-02',
      accessKeyId: options.accessKeyId,
      region: options.region,
      secretAccessKey: options.secretAccessKey,
    })
    this._queue = queue
    this._streamName = streamName
    this._logger = logger
  }

  /**
   * log an event that is serialized to JSON
   *
   * @function SQSEventLogger#info
   * @param {string} data the event data serialized as JSON
   */
  info(data) {
    const params = { QueueUrl: this._queue.url, MessageBody: data.toString() }
    this._sqs.sendMessage(params, (err, result) => {
      if (!err) {
        this._logger.debug('successfully enqueued message', {
          type: 'sqs',
          url: this._queue.url,
          id: result.MessageId,
        })
        return
      }
      this._logger.error('could not enqueue event', { event: data })
      this._logger.error(err)
      const kinesisParams = {
        Data: data.toString(),
        PartitionKey: uuid.v4(),
        StreamName: this._streamName,
      }
      this._kinesis.putRecord(kinesisParams, (err, result) => {
        if (!err) {
          this._logger.debug('successfully backup enqueued message', {
            type: 'kinesis',
            id: result.SequenceNumber,
            shard: result.ShardId,
          })
        }
        this._logger.error('could not backup enqueue event', { event: data })
        this._logger.error(err)
        return
      })
      return
    })
  }
}

let legacyLogger = new winston.Logger({
  levels: winston.config.syslog.levels,
  transports: [],
})

// We need to expose the global logger as a proxy to handle the fact that we set the
// logger based on the config at runtime, but various modules (models/tag.js, for example)
// access the logger at module import time, which results in the original, temporary console logger
// being used for all logs in the module. That stinks!
function loggerProxy() {
  this.debug = util.deprecate(function () {
    return legacyLogger.debug.apply(legacyLogger, arguments)
  }, 'debug: use lib/logging')
  this.info = util.deprecate(function () {
    return legacyLogger.info.apply(legacyLogger, arguments)
  }, 'info: use lib/logging')
  this.warn = util.deprecate(function () {
    return legacyLogger.warning.apply(legacyLogger, arguments)
  }, 'warn: use lib/logging')
  this.error = util.deprecate(function () {
    // Check arguments to translate Error objects as winston's logstash option
    // will corrupt them for further use. Ignore the first argument as that
    // should always be a format string.
    const args = Array.prototype.slice.call(arguments)
    for (let i = 1; i < args.length; i++) {
      if (args[i] instanceof Error) args[i] = _.pick.apply(_, [args[i]].concat(errorLoggingFields))
    }
    return legacyLogger.error.apply(legacyLogger, args)
  }, 'error: use lib/logging')
  this.log = util.deprecate(function () {
    return legacyLogger.log.apply(legacyLogger, arguments)
  }, 'log: use lib/logging')
  Object.defineProperty(this, 'transports', {
    get() {
      return legacyLogger.transports
    },
  })
}

const createEventLogger = function (settings) {
  // If we're in test the test logger is already created, so return our loggerProxy so we can suppress if we want in a test.
  if (process.env.NODE_ENV === 'test') {
    return new loggerProxy()
  }
  if (settings.type === 'SQS' || settings.type === 'QUEUE') {
    try {
      return new SQSEventLogger(settings.aws, settings.queue, settings.streamName, legacyLogger)
    } catch (err) {
      this.logger.error('SQSEventLogger ERROR', err)
      this.logger.error('Defaulting to LOG for event logger')
      settings.type = 'LOG'
    }
  }
  if (typeof settings.type === 'undefined' || settings.type === 'LOG') {
    const transports = []
    if (settings && settings.path) {
      transports.push(
        new winston.transports.File({
          json: false,
          filename: settings.path,
          formatter: options => {
            return options.message
          },
        }),
      )
    }

    return new winston.Logger({
      level: settings && settings.level ? settings.level.toLowerCase() : 'debug',
      levels: winston.config.syslog.levels,
      transports,
    })
  }
}

const eventLogger = createEventLogger(config.eventLogger)
